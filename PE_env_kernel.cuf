!
!  PE_env_kernel.cuf
!
!  CUDA Fortran Source File 
!  Generated by PGI Visual Fortran(R)
!  3/14/2012 9:40:52 AM
!


attributes(global) subroutine efunc1(nz2_d,dz_d,ALPHA0_d, &
  bdint_d, dbdint_d,bssint_d,bgint_d,wvln_d, ssint,blint_d,&
  ub0_d,depcalc_d,dbssint_d,dbgint_d,dblint_d,udb0_d,ang,aloss,&
  filt,envr,envi,envr2,envi2,c0_d,dr_d,fk0_d,rsint_d,rsdot2int_d,&
  test,rsdotint_d)
!"Do 5000" loop
implicit none
include "efunc1_var.fi"

	i = (blockidx%x-1)*blockdim%x + threadidx%x
	rsint_d(1)=rsint

	if (i>nz) return
	envr(i) = 0
	envi(i) = 0
	envr2(i) = 0
	envi2(i) = 0


	if (i>nz2) return
	
	depth = (i-0.5)*dz
	
	vloss=ALPHA0*(1.-6.46E-5*depth)

	 

	if (bdint < dbdint) then
		
		rdepth = depth -bdint
		if(depth > bdint) then
		  if(depth > dbdint) then
		    ssintb = bssint + bgint*(dbdint-bdint)
		  else
		    ssintb= bssint+bgint*rdepth
		  end if
		else
		  ssintb = bssint
		end if

		
		
		r = min(max(rdepth/xl,-32.),32.)
		
		!  fctn1(xx)=1./(1.+exp(-xx))
		f1 = 1./(1.+exp(-r))
		
		ssint(i) = ssint(i) + f1*(ssintb-ssint(i))
		
		vloss = vloss+f1*(blint-vloss)

		
		
		ibot = 1

		if(xld.eq.xldmin) then
		  rdepthd = depth - dz*(int(bdint/dz+1.)-0.5)
		else
          rdepthd=depth-bdint
        end if

		if (rdepth <= -xld                              ) m=1
        if (rdepth >=  -xld     .and. rdepth < -0.5*xld) m=2
        if (rdepth >=  -0.5*xld .and. rdepth <  0.5*xld) m=3
        if (rdepth >=   0.5*xld .and. rdepth <  xld    ) m=4
        if (rdepth >=  xld                              ) m=5

        SELECT CASE (m)   
          CASE (1)  
             u=0.0
          CASE (2)    
             u=4.0*(1.+rdepth/xld)/xldsq
          CASE (3)  
             u=-4.0*rdepth/(xld*xldsq)
          CASE (4)  
             u=-4.0*(1.-rdepth/xld)/xldsq
          CASE (5)
             u=0.0
          CASE DEFAULT  

        END SELECT
	    en2 = ub0*u
		
	end if
	!test(i) = en2
	!return
	IF(dbdint.lt.depcalc)THEN
       rdepth=depth-dbdint
       if(depth.gt.dbdint)then
        ssintb=dbssint+dbgint*rdepth
       else
        ssintb=dbssint
       end if
       r=min(max(rdepth/xl,-32.),32.)
       f1 = 1./(1.+exp(-r))
       ssint(i)=ssint(i)+f1*(ssintb-ssint(i))
       vloss=vloss+f1*(dblint-vloss)

       ibot=2

!     Compute mixing function for density discontinuity at interface
       if(xld.eq.xldmin)then
         rdepthd=depth-dz*(int(dbdint/dz+1.)-0.5)
       else
         rdepthd=depth-dbdint
       end if

       if (rdepth <= -xld                              ) m=1
       if (rdepth >=  -xld     .and. rdepth < -0.5*xld) m=2
       if (rdepth >=  -0.5*xld .and. rdepth <  0.5*xld) m=3
       if (rdepth >=   0.5*xld .and. rdepth <  xld    ) m=4
       if (rdepth >=  xld                              ) m=5

       SELECT CASE (m)   
          CASE (1)  
             u=0.0
          CASE (2)    
             u=4.0*(1.+rdepth/xld)/xldsq
          CASE (3)  
             u=-4.0*rdepth/(xld*xldsq)
          CASE (4)  
             u=-4.0*(1.-rdepth/xld)/xldsq
          CASE (5)
             u=0.0
          CASE DEFAULT  

       END SELECT
       en2=udb0*u+en2
      END IF


	   en=c0/ssint(i)
	  !test(i) = en
	  !return

!     Compute z-space operator for defined potential function

      ang(i)=dr*fk0*(1.-en+en2)
	  
!     Compute volume and bottom loss contributions and spatial filter
      !return
      aloss(i)=filt(i+1)*exp(-dr*vloss)
	  !aloss1 = filt(i+1)*exp(-dr*vloss)*cos(ang(i))
	  !aloss1 = 1
	  !envr(i) = real(aloss1)
	  !return
      envr(i)=aloss(i)*cos(ang(i))
      envi(i)=-aloss(i)*sin(ang(i))
      envr2(i)=sqrt(aloss(i))*cos(ang(i)/2.)
      envi2(i)=-sqrt(aloss(i))*sin(ang(i)/2.)

	  
!5000 CONTINUE
	  !return
	  end subroutine


attributes(global) subroutine efunc2(nz2_d,dz_d,ALPHA0_d, &
  bdint_d, dbdint_d,bssint_d,bgint_d,wvln_d, ssint,blint_d,&
  ub0_d,depcalc_d,dbssint_d,dbgint_d,dblint_d,udb0_d,ang,aloss,&
  filt,envr,envi,envr2,envi2,c0_d,dr_d,fk0_d,rsint_d,rsdot2int_d,&
  test,rsdotint_d)

implicit none
include "efunc1_var.fi"

	i = (blockidx%x-1)*blockdim%x + threadidx%x
	

	
	 
	
      if(rsint.ne.0.)then
        if(rsint.gt.0.)then
          ns=int(rsint/dz+0.5)
        else
          ns=int(rsint/dz-0.5)
        end if
		
	  iz = i
	  
	  if(ns.gt.0)then
	  
	    if (iz>=1.and.iz<=ns) then
		    !envr(iz) = 1;return
		    !return
            dep=(float(iz)-0.5)*dz
	        angs=ang(2*ns+1-iz)-dr*fk0*2.0*(dep-rsint)*rsdot2int
            envr(iz)=aloss(2*ns+1-iz)*cos(angs)
            envi(iz)=-aloss(2*ns+1-iz)*sin(angs)
            envr2(iz)=sqrt(aloss(2*ns+1-iz))*cos(angs/2.)
            envi2(iz)=-sqrt(aloss(2*ns+1-iz))*sin(angs/2.)
	    end if
		
	    if( iz>=2*ns+1.and.iz<=nz/2) then
		    
			jz=nz-iz+2*ns+1
	        !envr(jz) = 2;return
			dep=(float(jz-nz)-0.5)*dz
	        angs=ang(iz)-dr*fk0*2.0*(dep-rsint)*rsdot2int
            envr(jz)=aloss(iz)*cos(angs)
            envi(jz)=-aloss(iz)*sin(angs)
            envr2(jz)=sqrt(aloss(iz))*cos(angs/2.)
            envi2(jz)=-sqrt(aloss(iz))*sin(angs/2.)
	    end if
		
	    if( iz>=nz/2+1.and.iz<=nz/2+2*ns)then
		!envr(iz) = 3;return
	        dep=(float(iz-nz)-0.5)*dz
	        angs=ang(nz/2)-dr*fk0*2.0*(dep-rsint)*rsdot2int
			envr(iz)=aloss(nz/2)*cos(angs)
            envi(iz)=-aloss(nz/2)*sin(angs)
            envr2(iz)=sqrt(aloss(nz/2))*cos(angs/2.)
            envi2(iz)=-sqrt(aloss(nz/2))*sin(angs/2.)
	    end if
		return
	  end if
	  !return
	  if(ns.le.0)then
	    
	    ns=-ns
	    sspd1=ssint(1)
	    sspd2=ssint(2)
		sspdint=sspd1-sspd2
	    if (iz>=1.and.iz<=ns)then
		  
	      sspd=sspd1+iz*sspdint
	      en=c0/sspd
          angs=dr*fk0*(1.-en)
	      jz=nz-iz+1
		  !envr(jz) = 1;return
	      envr(jz)=aloss(1)*cos(angs)
	      envi(jz)=-aloss(1)*sin(angs)
	      envr2(jz)=sqrt(aloss(1))*cos(angs/2.)
	      envi2(jz)=-sqrt(aloss(1))*sin(angs/2.)
!	Removed Do loop that used iz=1,ns
	      mz=nz-2*ns+iz
	      dep=(float(mz-nz)-0.5)*dz
!	Replaced reference to previous do loop (removed jz; put in 1)
	      angs=angs-dr*fk0*2.0*(dep-rsint)*rsdot2int
          envr(mz)=aloss(1)*cos(angs)
          envi(mz)=-aloss(1)*sin(angs)
          envr2(mz)=sqrt(aloss(1))*cos(angs/2.)
          envi2(mz)=-sqrt(aloss(1))*sin(angs/2.)
	    end if
		
	    if (iz>=1.and.iz<=(nz/2-2*ns)) then
	      jz=nz-2*ns+1-iz

		  !envr(jz) = 2;return
	      dep=(float(jz-nz)-0.5)*dz
		  
	      angs=ang(iz)-dr*fk0*2.0*(dep-rsint)*rsdot2int
          envr(jz)=aloss(iz)*cos(angs)
          envi(jz)=-aloss(iz)*sin(angs)
          envr2(jz)=sqrt(aloss(iz))*cos(angs/2.)
          envi2(jz)=-sqrt(aloss(iz))*sin(angs/2.)
		  !test(jz) = dep
		  !test(2) = rsdot2int
	    end if
	  end if

    end if
	
	  return

end subroutine


attributes(global) subroutine efunc3(ssint,ss1,ss2,fss,nz_d)
! ssint(i)=ss1(i)+fss*(ss2(i)-ss1(i))
implicit none
real, dimension(*)::ss1, ss2, fss,ssint
integer, dimension(*):: nz_d
integer :: i
i = (blockidx%x-1)*blockdim%x + threadidx%x
if (i>nz_d(1)) return
ssint(i) = ss1(i)+fss(1)*(ss2(i)-ss1(i))
end subroutine

attributes(global) subroutine efunc4(a,b)
implicit none
include 'envprop_type.fi'

type(envprop_type):: a
real, dimension(*)::b
b(1) = a%sigsmax
b(2) = a%dr
b(3) = a%etas(1)
b(4) = a%a(2)
end subroutine